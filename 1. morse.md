Morse avec Arduino
==================

Eclairer
=======

Dans l'exemple Blink, nous voyons que `digitalWrite` permet
de changer l'√©tat d'un `pin`.

```
void loop() {
    digitalWrite(13, HIGH); // allumer le pin 13
    delay(1000); // attendre 1 seconde
    digitalWrite(13, LOW); // eteindre le pin 13
    delay(1000); // attendre 1 seconde
}
```

Pour le premier exercice, nous allons cr√©er une `fonction`
qui va s'appeller "eclairer" et qui nous permettra d'allumer
facilement le pin 13 pendant 500 millisecondes.

Mais c'est quoi une fonction ? Une fonction c'est un morceau
de code que l'on pourra facilement r√©utiliser plusieurs fois
dans notre programme. Ca √©vite de se r√©peter et ca permet de
mieux comprendre comment le programme marche.

Le but de la fonction `eclairer` sera d'allumer la diode,
de laisser la diode allum√©e pendant un certain temps, puis
de l'√©teindre.

Avec `digitalWrite(13, LOW)`, `digitalWrite(13, HIGH)` et
`delay`, vous avez avec vous tous les outils pour cr√©er cette fonction. Pour vous faciliter la t√¢che, j'ai √©crit le
squelette de la fonction ici:

```
void eclairer() {
    // ecrire le code la fonction ici
}
```

A vous de jouer !

‚úÖ Solution

```
void eclairer() {
    digitalWrite(13, HIGH); // allumer la diode
    delay(500); // attendre 500 ms
    digitalWrite(13, LOW); // eteindre la diode
}
```

Eclairer 2 : les param√®tres 
===========================

Cool ! Maintenant on peut allumer la lampe facilement üî•‚òÄüî•Ô∏è

On peut facilement allumer la diode
pendant 500ms. Mais que se passe-t-il si l'on veut
allumer la diode pendant 50ms ou alors 100ms ou 500ms ?

On pourrait copier-coller `eclairer` et changer la dur√©e
d'attente √† chaque fois :

```
void eclairer_500() {
    digitalWrite(13, HIGH); // allumer la diode
    delay(500); // attendre 500 ms
    digitalWrite(13, LOW); // eteindre la diode
}

void eclairer_50() {
    digitalWrite(13, HIGH); // allumer la diode
    delay(50); // attendre 50 ms
    digitalWrite(13, LOW); // eteindre la diode
}

void eclairer_100() {
    digitalWrite(13, HIGH); // allumer la diode
    delay(100); // attendre 100 ms
    digitalWrite(13, LOW); // eteindre la diode
}
```

Ca commence d√©j√† √† faire pas mal de code üìùüìùüìù... Et puis, on
va devoir si on veut eclairer pendant seulement 200ms, on
va devoir encore copier-coller une fonction.

Le mieux serait que l'on puisse dire √† `eclairer` d'eclairer
pendant un certain temps comme on dit √† `delay` d'attendre un
certain temps.

```
delay(50); // attendre 50ms
delay(500); // attendre 500ms
delay(100); // attendre 100ms
```

Comment fait-on cela ? En utilisant ce qu'on appelle des *param√®tres* !

Voici la version d'`eclairer` avec des param√®tres :

```
void eclairer (int duree) {
    digitalWrite(13, HIGH); // allumer la diode
    delay(duree); // attendre `duree` ms
    digitalWrite(13, LOW); // eteindre la diode
}
```

Et voici comment l'utiliser :

```
eclairer(500); // eclaire pendant 500ms
eclairer(200); // eclaire pendant 200ms
eclairer(25); // eclaire pendant 25ms
```

C'est beaucoup plus simple que de copier coller plein de fois
le m√™me code üòé !

On a rajout√© le *param√®tre* `duree` de *type* `int`. Il est
maintenant disponible √† l'int√©rieur de la fonction et est
remplac√© lorsqu'on *appelle* la *fonction*.

```
eclairer(500);
```

est √©quivalent √†:

```
digitalWrite(13, HIGH); // allumer la diode
delay(500); // attendre 500 ms
digitalWrite(13, LOW); // eteindre la diode
```

maintenant !

### Exercice

Modifier la fonction `eclairer` pour qu'elle √©claire 2
fois plus longtemps que la dur√©e qu'on lui donne.

Rappel: Pour multiplier, on utilise une √©toile : `*`.

```
int a = 4;
int b = 2 * a; // ici b sera √©gal √† 8
```

‚úÖ Solution de l'exercice:

```
void eclairer (int duree) {
    digitalWrite(13, HIGH);
    delay(2 * duree);
    digitalWrite(13, LOW);
}
```

### Exercice

Remplir les trous :

```
int DUREE_TI = 50;
int DUREE_TA = 3 * DUREE_TI;

void ti() {
    ____________
}

void ta() {
    ____________
}

```

Lorsqu'on appelle `ti`, il faut que la diode
s'allume pendant 50ms. Attention, n'utilisez pas 50ms
directement dans la fonction ti ! Vous pouvez utiliser
les variables d√©j√† d√©finies...

Lorsqu'on appelle `ta`, il faut que la diode
s'allume 3 fois plus longtemps que pour le `ti`.

‚úÖ Solution

```
void ti() {
    eclairer(DUREE_TI);
}


void ta() {
    eclairer(DUREE_TA);
}
```

Ne vous inqui√©tez pas si tout n'est pas encore tr√®s clair
pour vous, ca va venir...

On va revoir un peu les d√©finitions:

`variable` : une variable est comme une boite ou l'on met une valeur

```
int a = 1; // on peut maintenant utiliser "a" autre part dans le code
```

`type`: permet de dire le type de boite qu'on utilise pour une variable.
En informatique, si on a choisit que `a` √©tait une bo√Æte pour contenir
des nombres, on ne va pas pouvoir mettre des lettres √† l'int√©rieur.

Voici les types que l'on a d√©j√† pu rencontrer jusqu'√† pr√©sent :

* `void` : utilis√© avant les `fonctions`

* `int`: permet de faire des variables qui vont contenir des nombres


`fonction`: contient du code que l'on va pouvoir appeller plus tard.
Les fonctions sont les briques de l'informatique. L'Arduino conna√Æt
d√©j√† des fonctions de base comme `digitalWrite` et nous cr√©ons des
fonctions √† partir des ces fonctions pour nous permettre de construire
des programmes qui permettent de faire des choses de plus en plus
compliqu√© !

`param√®tre`: permet de faire varier le comportement d'une fonction. Le
premier exemple de fonction que l'on a vu avec un param√®tre, c'est 
`delay` qui *prend en param√®tre* le temps d'attente. `digitalWrite`, elle, prend 2 param√®tre : le num√©ro du pin que l'on veut changer et la
valeur que l'on veut que le pin prenne.

SOS
===

On a maintenant les briques de bases, le `ti` et le `ta`
qui permettent allumer la diode. On peut d√©j√† commencer √† √©mettre
l'un des signaux les plus connus du Morse !

```
¬∑ ¬∑ ¬∑ ‚Äî ‚Äî ‚Äî ¬∑ ¬∑ ¬∑
```

En morse, ce signal veut dire SOS et si vous le voyez √©mis par
quelqu'un, cela signifie que cette personne a besoin d'aide (ou alors
qu'elle est en train, comme vous, de programmer un Arduino...).

### üìù Exercice

Remplir la fonction SOS:

```
void SOS () {
    ti();
    ti();
    ti();
    ________
    ________
    ________
    ________
    ________
    ________
}
```

Les cha√Ænes de caract√®res
-------------------------


### type et constructeur

Pour l'instant nous n'avons eu √† travailler qu'avec des variables de type `int`
comme `duree` mais il y a beaucoup d'autres types √† d√©couvrir. Imaginons que nous
voulions √©crire l'alphabet. Par exemple, si nous avons envie de mettre plusieurs
lettres dans une variable, il faut utiliser le type `String`.

```
String alphabet = String("abcdefghijklmnopqrstuvwxyz");
```

String veut dire cha√Æne de caract√®res car il faut imaginer que dans l'ordinateur,
"abcdefghijklmnopqrstuvwxyz" est stock√©e comme si chaque lettre √©tait un maillon
reli√© √† la prochaine lettre :

```
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z
```

Le premier String est le `type` de la variable "alphabet" mais √† quoi sert le
deuxi√®me String ? Il ressemble √† une *fonction* car on l'*appelle* avec des
parenth√®ses. C'est effectivement une fonction : String est un type et une
fonction en m√™me temps. Utilis√© comme le premier, c'est un type, utilis√©
comme le deuxi√®me, c'est une fonction qui nous permet de "construire" la
cha√Æne (les maillons etc...) : on l'appelle le *constructeur*.

Donc pour r√©sumer, lorsqu'on utilise une cha√Æne de caract√®res, il faut 

* d√©clarer le type de la variable comme *String*
* utiliser le *constructeur* *String*

```
String prenom = String("pierrot");
String code_sos = String("...---...");
```

Vous vous posez peut-√™tre la question, mais pourquoi n'a-t-on pas besoin
d'utiliser un constructeur avec les `int` ? C'est une bonne question. C'est
parce que les `int` sont des types tr√®s simples tandis que les `String` sont
des types un peu plus complexes que l'on appelle des `objets`.

Un objet ?

Un objet est une variable `sur lequel` on peut `appeller` des fonctions.
Par exemple, pour une `String`, on peut avoir besoin de savoir sa longueur.
On peut utiliser la fonction `length`.

```
String alphabet = String("abcdefghijklmnopqrstuvwxyz");
int longueur_alphabet = alphabet.length(); // 26

String coca = String("coca-cola");
int longueur_coca = coca.length(); // 9
``` 

Le point attache la variable "alphabet"  et la fonction `length` ensemble,
on dit qu'on appelle la fonction `length` de la variable `alphabet`.

### Exercices

üìù 1. Stocker dans des variables les longueurs des cha√Ænes de caract√®res :

* "fonction"
* "parametres"
* "chocolat"
* "qui a une tete de beurre ne doit pas s'approcher du four."

Recevoir des informations de l'Arduino
--------------------------------------

Pour l'instant, on a fait que donner des instructions √† l'Arduino, comment faire
pour recevoir des informations ?

On va utiliser les fonctions qui sont dans `Serial`. Lorsque je dis, les fonctions
dans Serial, c'est √† dire que les fonctions s'√©criront toutes avec `Serial.` devant.
Comme pour les `fonctions` des `String`, le point (".") fait la liaison.

Avant de pouvoir recevoir des donn√©es, il faut un peu de pr√©paration, on doit rajouter
cette ligne dans la `fonction` setup :

```
Serial.begin(9600);
```

`begin` veut dire commencer en anglais et sert √† dire que l'on va communiquer
avec l'Arduino, on dit qu'on "ouvre" la communication.
Le 9600 indique la vitesse de communication entre l'ordinateur et l'Arduino.

Maintenant qu'on a ouvert la communication, nous pouvons utiliser la fonction `println`
pour √©crire des choses. Il faut ouvrir le "Moniteur Serial" dans la fen√™tre de l'Arduino
pour pouvoir voir les choses qu'√©crit l'Arduino.

* `print` veut dire "imprimer" et veut dire que l'on va √©crire quelque chose

* `ln` veut dire "line", "ligne" en fran√ßais et veut dire qu'apr√®s avoir √©crire quelque chose
   on va passer √† la ligne.

### Exercice

üìù 1. Ecris des choses

```
Serial.println("toto");
Serial.println(123);
Serial.println(4 * 5);
Serial.println(4 * 5);
```

üìù 2. Testes la fonction `print` (sans `ln`)

----

Cool ! Maintenant que l'on sait √©crire des choses ‚úèÔ∏è, on peut combiner avec ce que l'on a vu avant.

Essayer de combiner `Serial.println` et la fonction `length` des String pour √©crire la longueur
des cha√Ænes de caract√®res vues pr√©cd√©mment.

Si vous voulez tester avec l'Arduino, faites une fonction `test` ou vous mettez ce que vous voulez
et mettez l√† dans la fonction setup() de l'Arduino, comme √ßa, elle ne sera execut√©e qu'une fois.

‚úÖ Solution :

```

void setup () {
    Serial.begin(9600);
    test()
}

void test() {
    String a = String("fonction");
    String b = String("parametres");
    String c = String("chocolat");a
    String d = String("qui a une tete de beurre ne doit pas s'approcher du four.");

    int longueur_a = a.length();
    int longueur_b = b.length();
    int longueur_c = c.length();
    int longueur_d = d.length();

    Serial.print("La longueur de a est ");
    Serial.println(longueur_a);


    Serial.print("La longueur de b est ");
    Serial.println(longueur_b);

    Serial.print("La longueur de c est ");
    Serial.println(longueur_c);


    Serial.print("La longueur de d est ");
    Serial.println(longueur_d);
}

void loop () {
    // on ne met rien, on en a pas besoin
}
```

‚úÖ Solution 2 :

Ici vous pouvez voir du code qui se r√©p√©te. Le code qui se r√©pete, c'est emb√™tant car si on veut changer
quelque chose on doit le changer √† plusieurs endroits et c'est plus long. Imaginez que je veuille
non plus avoir "la longueur de a est 8" mais "longueur a: 8" et pareil pour `b`, `c`, et `d`. Je devrais changer
4 lignes ! Pour l'instant ce n'est pas beaucoup, mais dans un programme plus long, ca peut vite devenir
plus compliqu√©.

Que fait-on lorsqu'on ne veut pas r√©peter des choses ? On utilise les fonctions !

Exercice: √©crivez la `fonction` "ecrire_longueur_chaine" qui prendra en param√®tre une
cha√Æne de caract√®res et qui √©crira "Longueur de la chaine "[LA CHAINE ICI]" : [LA LONGUEUR ICI]".

Par exemple, `ecrire_longueur_chaine("abcdef")` devrait √©crire :

```
Longueur de la chaine "abcdef" : 6
```

Indice 1 : squelette de la fonction

```
void ecrire_longueur_chaine (String chaine) {
    
}
```

Structures de contr√¥le
======================

Lire https://openclassrooms.com/courses/programmez-vos-premiers-montages-avec-arduino/faites-des-boucles-et-des-calculs

Parcourir une string
====================

Vous avez vu la boucle `for` et comment elle permet de r√©peter un bloc d'instructions plusieurs fois. Nous allons
l'utiliser pour "parcourir" une String, c'est √† dire passer sur tout les caract√®res. A la fin de cette section, avec
une `String` comme "abcdefghi", vous pourrez √©crire :

```
a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z
``` 

Avant de faire √ßa, nous allons apprendre une autre *fonction* des `String`. D'ailleurs √† propos, les *fonctions*
li√©es aux *objets* sont appell√©es des m√©thodes, j'utiliserai donc ce mot l√† √† partir de maintenant. `length`
est donc une m√©thode des `String`s.

Donc apprenons, une nouvelle *m√©thode* des String.

```
void test = "abcde";
Serial.println(test.charAt(2));
Serial.println(test.charAt(1));
Serial.println(test.charAt(0));
```

Executez ce code dans votre Arduino et essayez de comprendre ce qui se passe.

Tu as trouv√© ?

`charAt` permet de r√©cup√©rer le caract√®re √† la position donn√©e. N'oublie pas, comme l'ordinateur
compte √† partir de 0, lorsque l'on fait `charAt(0)`, on r√©cupere le *premier* caract√®re.

Nous sommes pr√™ts maintenant √† parcourir la cha√Æne. Revoyons les m√©thodes que l'on conna√Æt sur les cha√Ænes :

* `length` permet de conna√Ætre la longueur
* `chatAt` permet de r√©cup√©rer un caract√®re √† un index donn√©

Une boucle a besoin d'un d√©but et d'une fin. Pour parcourir tout les caract√®res, il va falloir que l'on
d√©bute √† 0 et que l'on aille jusqu'au bout ?

‚ùì Question : Comment va-t-on faire pour aller au bout ?

Pour aller jusqu'au bout de la cha√Æne, nous allons utiliser la m√©thode `length`:

```
for (int i = 0; i < chaine.length(); i++) {
    String lettre = ______; // il faut maintenant acceder √† chacun des caract√©res
}
```

‚ùì Question : Qu'est ce que l'on doit mettre dans la boucle pour acc√©der √† chaque lettre ?

C'est `charAt` cette fois que l'on utilise !

```
for (int i = 0; i < chaine.length(); i++) {
    String lettre = chaine.charAt(i); // il faut maintenant acceder √† chacun des caract√©res
}
```

Avec `charAt`, nous demandons la i-√®me lettre de la cha√Æne. Maintenant, nous pouvons √©crire
tout l'alphabet, une lettre par ligne.

üìù 1. Ecris tout l'alphabet une lettre par ligne

‚úÖ Solution 
```
for (int i = 0; i < chaine.length(); i++) {
    String lettre = chaine.charAt(i); // on accede au i-eme caractere
    Serial.printLn(lettre); // on ecrire la lettre et on va a la ligne
}
```

üìù 2. Testes ce code sur ton Arduino

Emettre du morse √† partir du code
=================================

Maintenant, ca commence √† devenir int√©ressant, on sait parcourir une cha√Æne de caract√®re lettre
par lettre et on sait faire des `ti()` et des `ta()`. On va maintenant √©crire une fonction
qui pourra faire les `ti()` et les `ta()` directement √† partir du code morse.

Aper√ßu:

```

void emettre_code(String code) {
    // on va ecrire le code ici
}


void test() {
    String code_a_emettre = String("...--- ..---.-. ----. ---.....");
    emettre_code(code_a_emettre);
}
```

Comment faire pour emettre le code ? R√©fl√©chissez un peu puis regarder le *pseudo-code* que j'ai
√©cris en dessous. Le *pseudo-code* est une mani√®re d'√©crire les choses un peu comme le code
mais ca ne marchera pas, c'est juste pour voir ce que cela va donner.

```
void emettre_code(String code) {
    pour chaque lettre dans code
        si c'est un point on fait ti()
        si c'est un tiret on fait ta()
}
```

Vous remarquez que j'ai utilis√© `si` et si vous avez bien lu le cours sur les structures de
contr√¥le, vous devez vous rappeller du `if`. Revoyez le cours si ce n'est pas bien clair pour vous.

üìù 1. Ecris la vraie fonction emettre_code

‚úÖ Solution 
```
void emettre_code (String code) {
    int taille_code = code.length();
    for (int i = 0; i < taille_code; i++) {
        String lettre = code.charAt(i);
        if (lettre == ".") {
            ti();
        }
        if (lettre == '-') {
            ta();
        }
        if (lettre == ' ') {
            delay(duree_ta);
        }
    }
}
}
```


